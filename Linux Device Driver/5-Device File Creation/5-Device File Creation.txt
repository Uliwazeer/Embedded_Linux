/dev/ directory. The device file is important to communicate with the hardware. Let’s start our tutorial.

The device file allows transparent communication between user-space applications and hardware.

All device files are stored in /dev directory. Use ls command to browse the directory:

ls -l /dev/

You can also use chmod to set the permissions for a device file after creation.

Advantages:
Anyone can create the device file using this method.
You can create the device file even before loading the driver.
**************************************************************************
Creating Device File
We can create a device file in two ways.

1-Manually
2-Automatically
**************************************************************************
Manually Creating Device File
We can create the device file manually by using mknod.

mknod -m <permissions> <name> <device type> <major> <minor>

<name> – Your device file name that should have a full path (/dev/name)

<device type> – Put c or b

c – Character Device

b – Block Device

<major> – major number of your driver

<minor> – minor number of your driver

-m <permissions> – optional argument that sets the permission bits of the new device file to permissions

sudo mknod -m 666 /dev/etx_device c 246 0
**************************************************************************
/***************************************************************************//**
*  \file       driver.c
*
*  \details    Simple linux driver (Manually Creating a Device file)
*
*  \author     Ali_Wazeer
*
*  \Tested with Linux raspberrypi 5.10.27-v7l-Ali_Wazeer-custom+
*
*******************************************************************************/
#include<linux/kernel.h>
#include<linux/init.h>
#include<linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
 
dev_t dev = 0;

/*
** Module init function
*/
static int __init hello_world_init(void)
{
        /*Allocating Major number*/
        if((alloc_chrdev_region(&dev, 0, 1, "Ali_Wazeer_Dev")) <0){
                pr_err("Cannot allocate major number for device\n");
                return -1;
        }
        pr_info("Kernel Module Inserted Successfully...\n");
        return 0;
}

/*
** Module exit function
*/
static void __exit hello_world_exit(void)
{
        unregister_chrdev_region(dev, 1);
        pr_info("Kernel Module Removed Successfully...\n");
}
 
module_init(hello_world_init);
module_exit(hello_world_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ali_Wazeer <Ali_Wazeer@gmail.com>");
MODULE_DESCRIPTION("Simple linux driver (Manually Creating a Device file)");
MODULE_VERSION("1.1");
**************************************************************************
Automatically Creating Device File
The automatic creation of device files can be handled with udev. Udev is the device manager for the Linux kernel that creates/removes device nodes in the /dev directory dynamically. Just follow the below steps.

Include the header file linux/device.h and linux/kdev_t.h
Create the struct Class
Create Device with the class which is created by the above step
**************************************************************************
Create the class
This will create the struct class for our device driver. It will create a structure under/sys/class/.

struct class * class_create(struct module *owner, const char *name);

owner – pointer to the module that is to “own” this struct class

name – pointer to a string for the name of this class

This is used to create a struct class pointer that can then be used in calls to class_device_create. The return value can be checked using IS_ERR() macro.

Note, the pointer created here is to be destroyed when finished by making a call to class_destroy.

void class_destroy (struct class * cls);
Create Device
This function can be used by char device classes. A struct device will be created in sysfs, and registered to the specified class.

struct device *device_create(struct *class, struct device *parent, dev_t dev, void * drvdata, const char *fmt, ...);
class – pointer to the struct class that this device should be registered to

parent – pointer to the parent struct device of this new device, if any

devt – the dev_t for the char device to be added

drvdata – the data to be added to the device for callbacks

fmt – string for the device’s name

... – variable arguments
**************************************************************************
A “dev” file will be created, showing the dev_t for the device, if the dev_t is not 0,0. If a pointer to a parent struct device is passed in, the newly created struct device will be a child of that device in sysfs.

The pointer to the struct device will be returned from the call. Any further sysfs files that might be required can be created using this pointer. The return value can be checked using IS_ERR() macro.

Note, that you can destroy the device using device_destroy().

void device_destroy (struct class * class, dev_t devt);
**************************************************************************
/***************************************************************************//**
*  \file       driver.c
*
*  \details    Simple linux driver (Automatically Creating a Device file)
*
*  \author     Ali_Wazeer
*
*  \Tested with Linux raspberrypi 5.10.27-v7l-Ali_Wazeer-custom+
*
*******************************************************************************/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/err.h>
#include <linux/device.h>
 
dev_t dev = 0;
static struct class *dev_class;
 
/*
** Module init function
*/
static int __init hello_world_init(void)
{
        /*Allocating Major number*/
        if((alloc_chrdev_region(&dev, 0, 1, "etx_Dev")) <0){
                pr_err("Cannot allocate major number for device\n");
                return -1;
        }
        pr_info("Major = %d Minor = %d \n",MAJOR(dev), MINOR(dev));
 
        /*Creating struct class*/
        dev_class = class_create(THIS_MODULE,"etx_class");
        if(IS_ERR(dev_class)){
            pr_err("Cannot create the struct class for device\n");
            goto r_class;
        }
 
        /*Creating device*/
        if(IS_ERR(device_create(dev_class,NULL,dev,NULL,"etx_device"))){
            pr_err("Cannot create the Device\n");
            goto r_device;
        }
        pr_info("Kernel Module Inserted Successfully...\n");
        return 0;
 
r_device:
        class_destroy(dev_class);
r_class:
        unregister_chrdev_region(dev,1);
        return -1;
}
 
/*
** Module exit function
*/
static void __exit hello_world_exit(void)
{
        device_destroy(dev_class,dev);
        class_destroy(dev_class);
        unregister_chrdev_region(dev, 1);
        pr_info("Kernel Module Removed Successfully...\n");
}
 
module_init(hello_world_init);
module_exit(hello_world_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ali_Wazeer <Ali_Wazeer@gmail.com>");
MODULE_DESCRIPTION("Simple linux driver (Automatically Creating a Device file)");
MODULE_VERSION("1.2");
