Module Parameters Macros

module_param()
module_param_array()
module_param_cb()
**************************************************************************
There are several types of permissions:

S_IWUSR
S_IRUSR
S_IXUSR
S_IRGRP
S_IWGRP
S_IXGRP

In this S_I is a common header.
R = read ,W =write ,X= Execute.
USR =user ,GRP =Group
Using OR ‘|’ (or operation) we can set multiple permissions at a time.
**************************************************************************
module_param()
This macro is used to initialize the arguments. module_param takes three parameters: the name of the variable, its type, and a permissions mask to be used for an accompanying sysfs entry. The macro should be placed outside of any function and is typically found near the head of the source file. module_param() macro, defined in linux/moduleparam.h.

module_param(name, type, perm);

module_param() macro creates the sub-directory under /sys/module. For example,

module_param(valueETX, int, S_IWUSR|S_IRUSR);
**************************************************************************
Numerous types are supported for module parameters:

bool
invbool
A boolean (true or false) value (the associated variable should be of type int). The invbool type inverts the value, so that true values become false and vice versa.

charp
A char pointer value. Memory is allocated for user-provided strings, and the pointer is set accordingly.

int
long
short
uint==unsighned interger
ulong==unsighned long
ushort==unsighned short
**************************************************************************
module_param_array()
This macro is used to send the array as an argument to the Linux device driver. Array parameters, 

module_param_array(name,type,num,perm);

name is the name of your array (and of the parameter),

type is the type of the array elements,

num is an integer variable (optional) otherwise NULL,

perm is the usual permissions value.
**************************************************************************
module_param_cb()
This macro is used to register the callback. Whenever the argument (parameter) got changed, this callback function will be called.

module_param(valueETX, int, S_IWUSR|S_IRUSR);

struct kernel_param_ops 
{
 int (*set)(const char *val, const struct kernel_param *kp);
 int (*get)(char *buffer, const struct kernel_param *kp);
 void (*free)(void *arg);
};
**************************************************************************
In this example, i explained all (module_param, module_param_array, module_param_cb).

For module_param(), I have created two variables. One is integer (valueETX) and another one is a string (nameETX).

For module_param_array(), I have created one integer array variable (arr_valueETX).

For module_param_cb(), I have created one integer variable (cb_valueETX).

You can change all variable using their sysfs entry which is under /sys/module/hello_world_module/parameters/
**************************************************************************
/***************************************************************************//**
*  \file       hello_world.c
*
*  \details    Simple hello world driver
*
*  \author     EmbeTronicX
*
* *******************************************************************************/
#include<linux/kernel.h>
#include<linux/init.h>
#include<linux/module.h>
#include<linux/moduleparam.h>
 
int valueETX, arr_valueETX[4];
char *nameETX;
int cb_valueETX = 0;
 
module_param(valueETX, int, S_IRUSR|S_IWUSR);                      //integer value
module_param(nameETX, charp, S_IRUSR|S_IWUSR);                     //String
module_param_array(arr_valueETX, int, NULL, S_IRUSR|S_IWUSR);      //Array of integers
 
/*----------------------Module_param_cb()--------------------------------*/
int notify_param(const char *val, const struct kernel_param *kp)
{
        int res = param_set_int(val, kp); // Use helper for write variable
        if(res==0) {
                printk(KERN_INFO "Call back function called...\n");
                printk(KERN_INFO "New value of cb_valueETX = %d\n", cb_valueETX);
                return 0;
        }
        return -1;
}
 
const struct kernel_param_ops my_param_ops = 
{
        .set = &notify_param, // Use our setter ...
        .get = &param_get_int, // .. and standard getter
};
 
module_param_cb(cb_valueETX, &my_param_ops, &cb_valueETX, S_IRUGO|S_IWUSR );
/*-------------------------------------------------------------------------*/

/*
** Module init function
*/
static int __init hello_world_init(void)
{
        int i;
        printk(KERN_INFO "ValueETX = %d  \n", valueETX);
        printk(KERN_INFO "cb_valueETX = %d  \n", cb_valueETX);
        printk(KERN_INFO "NameETX = %s \n", nameETX);
        for (i = 0; i < (sizeof arr_valueETX / sizeof (int)); i++) {
                printk(KERN_INFO "Arr_value[%d] = %d\n", i, arr_valueETX[i]);
        }
        printk(KERN_INFO "Kernel Module Inserted Successfully...\n");
    return 0;
}

/*
** Module Exit function
*/
static void __exit hello_world_exit(void)
{
    printk(KERN_INFO "Kernel Module Removed Successfully...\n");
}
 
module_init(hello_world_init);
module_exit(hello_world_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("EmbeTronicX <embetronicx@gmail.com>");
MODULE_DESCRIPTION("A simple hello world driver");
MODULE_VERSION("1.0");
**************************************************************************