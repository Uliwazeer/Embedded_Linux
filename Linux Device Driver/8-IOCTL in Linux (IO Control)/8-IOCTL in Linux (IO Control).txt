implementing IOCTL in Linux device drivers to enable communication between userspace and kernel space.
user space is the memory area where all user-mode applications work, and this memory can be swapped out when necessary.

There are many ways to Communicate between the Userspace and Kernel Space, they are:

IOCTL
Procfs
Sysfs
Configfs
Debugfs
Sysctl
UDP Sockets
Netlink Sockets
**************************************************************************
IOCTL is referred to as Input and Output Control, which is used to talk to device drivers. This system call is available in most driver categories. 

Some Real-time Applications of IOCTL are:

1-Ejecting the media from a “cd” drive
2-Changing the Baud Rate of the Serial port
3-Adjusting the Volume
4-Reading or Writing device registers
We already have the write and read function in our device driver. But it is not enough for all cases.
**************************************************************************
Steps Involved in IOCTL
There are some steps involved in Implementing IOCTL in Linux Device Drivers-

1-Create IOCTL command in the driver
2-Write the IOCTL function in the driver
3-Create IOCTL command in a Userspace application
4-Use the IOCTL system call in a Userspace
**************************************************************************
1. Create IOCTL Command in the Driver
To implement a new IOCTL command, we need to follow the following steps.

1. Define the IOCTL command:

#define "ioctl name" __IOX("magic number","command number","argument type")
where IOX can be :
“IO“: an ioctl with no parameters
“IOW“: an ioctl with write parameters (copy_from_user)
“IOR“: an ioctl with read parameters (copy_to_user)
“IOWR“: an ioctl with both write and read parameters

The Magic Number is a unique number or character that will differentiate our set of ioctl calls from the other ioctl calls. some times the major number for the device is used here.
Command Number is the number that is assigned to the ioctl. This is used to differentiate the commands from one another.
The last is the type of data.
2. Add the header file linux/ioctl.h to make use of the above-mentioned calls.

#include <linux/ioctl.h>

#define WR_VALUE _IOW('a','a',int32_t*)
#define RD_VALUE _IOR('a','b',int32_t*)
**************************************************************************
2. Write IOCTL Function in the Driver:
The next step is to implement the IOCTL call we defined into the corresponding driver. We need to add the ioctl function to our driver. Find the prototype of the function below.

int  ioctl(struct inode *inode,struct file *file,unsigned int cmd,unsigned long arg)
Where,

<inode>: is the inode number of the file being worked on.
<file>: is the file pointer to the file that was passed by the application.
<cmd>: is the ioctl command that was called from the userspace.
<arg>: are the arguments passed from the userspace

Within the function “ioctl” we need to implement all the commands that we defined above (WR_VALUE, RD_VALUE). We need to use the same commands in the switch statement which is defined above.

Then we need to inform the kernel that the ioctl calls are implemented in the function “etx_ioctl“. This is done by making the fops pointer “unlocked_ioctl” to point to “etx_ioctl” as shown below.


/*
** This function will be called when we write IOCTL on the Device file
*/
static long etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
         switch(cmd) {
                case WR_VALUE:
                        if( copy_from_user(&value ,(int32_t*) arg, sizeof(value)) )
                        {
                                pr_err("Data Write : Err!\n");
                        }
                        pr_info("Value = %d\n", value);
                        break;
                case RD_VALUE:
                        if( copy_to_user((int32_t*) arg, &value, sizeof(value)) )
                        {
                                pr_err("Data Read : Err!\n");
                        }
                        break;
                default:
                        pr_info("Default\n");
                        break;
        }
        return 0;
}

/*
** File operation sturcture
*/
static struct file_operations fops =
{
        .owner          = THIS_MODULE,
        .read           = etx_read,
        .write          = etx_write,
        .open           = etx_open,
        .unlocked_ioctl = etx_ioctl,
        .release        = etx_release,
};
**************************************************************************
3. Create IOCTL Command in a Userspace Application
Just define the ioctl command like how we defined it in the driver.

#define WR_VALUE _IOW('a','a',int32_t*)
#define RD_VALUE _IOR('a','b',int32_t*)
**************************************************************************
4. Use IOCTL System Call in Userspace
Include the header file <sys/ioctl.h>.Now we need to call the new ioctl command from a user application.

long ioctl( "file descriptor","ioctl command","Arguments");
Where,

<file descriptor>: This the open file on which the ioctl command needs to be executed, which would generally be device files.
<ioctl command>: ioctl command which is implemented to achieve the desired functionality
<arguments>: The arguments need to be passed to the ioctl command.

ioctl(fd, WR_VALUE, (int32_t*) &number); 

ioctl(fd, RD_VALUE, (int32_t*) &value);
**************************************************************************
Q. What is IOCTL Used for in Linux?

IOCTL is used to perform specific operations on device drivers that are not have standard system calls. 
It allows user-space applications 
to send control commands to the kernel-space driver and retrieve information or modify device behavior.


Q. How Does IOCTL Work?

IOCTL works by passing commands and optional arguments from the user-space application to the device driver in the kernel. 
The driver then interprets the command and performs the requested operation, such as reading or writing device registers


Q. Can IOCTL Pass Multiple Arguments Between User-space and kernel-space?

Yes, IOCTL can pass multiple arguments between user-space and kernel-space. If you need to pass multiple arguments, 
you can create a structure that contains 
all the necessary variables and pass the address of the structure as an argument in the IOCTL command.


Q. Are there Alternative Methods to IOCTL for Communication Between user-space and kernel-space?

Yes, there are alternative methods to IOCTL for communication between user-space and kernel-space in Linux. 
Some of these methods include Procfs, Sysfs, Configfs, Debugfs, Sysctl, UDP Sockets, and Netlink Sockets.