the interrupts and how the kernel responds to them, with special functions called interrupt handlers (ISR).

In Linux, interrupt signals are the distraction that diverts the processor to a new activity outside of the normal flow of execution. 
This new activity is called interrupt handler or interrupt service routine (ISR) and that distraction is Interrupts.
**************************************************************************
INTERRUPT
في المقاطعة، تعتني وحدة المعالجة المركزية بالأجهزة فقط عندما تطلب الأجهزة بعض الخدمات

المقاطعة مثل صاحب متجر. إذا احتاج المرء إلى خدمة أو منتج، يذهب إليه ويخبره باحتياجاته. في حالة المقاطعات، عند تلقي الأعلام أو الإشارات، يتم إخطار وحدة التحكم بأنها بحاجة إلى الخدمة.
**************************************************************************
POLLING

في عملية الاقتراع، تستمر وحدة المعالجة المركزية (CPU) في التحقق من جميع الأجهزة الخاصة بمدى توفر أي طلب

طريقة الاقتراع تشبه مندوب المبيعات. ينتقل البائع من باب إلى باب أثناء طلب شراء منتج أو خدمة. وبالمثل، تستمر وحدة التحكم في مراقبة العلامات أو الإشارات واحدًا تلو الآخر لجميع الأجهزة وتوفر الخدمة لأي مكون يحتاج إلى خدمته.
**************************************************************************
ماذا سيحدث عندما تأتي المقاطعة؟
يتم إنتاج المقاطعة بواسطة إشارات إلكترونية من الأجهزة ويتم توجيهها إلى دبابيس الإدخال الموجودة على وحدة تحكم المقاطعة (شريحة بسيطة تقوم بمضاعفة خطوط المقاطعة المتعددة في خط واحد إلى المعالج). هذه هي العملية التي سيتم تنفيذها بواسطة النواة.

عند تلقي المقاطعة، تقوم وحدة التحكم بالمقاطعة بإرسال إشارة إلى المعالج.
يكتشف المعالج هذه الإشارة ويقاطع تنفيذها الحالي للتعامل مع المقاطعة.
يمكن للمعالج بعد ذلك إخطار نظام التشغيل بحدوث مقاطعة، ويمكن لنظام التشغيل التعامل مع المقاطعة بشكل مناسب.
ترتبط الأجهزة المختلفة بمقاطعات مختلفة باستخدام قيمة فريدة مرتبطة بكل مقاطعة. يتيح ذلك لنظام التشغيل التمييز بين المقاطعات ومعرفة الجهاز الذي تسبب في مثل هذه المقاطعة. وفي المقابل، يمكن لنظام التشغيل خدمة كل مقاطعة باستخدام المعالج المقابل لها.

تعد معالجة المقاطعة من أكثر المهام حساسية التي تقوم بها النواة ويجب أن تستوفي ما يلي:

تقوم الأجهزة بإنشاء مقاطعات بشكل غير متزامن (فيما يتعلق بساعة المعالج). وهذا يعني أن المقاطعات يمكن أن تأتي في أي وقت.
نظرًا لأن المقاطعات يمكن أن تأتي في أي وقت، فقد تتعامل النواة مع إحداها أثناء حدوث مقاطعة أخرى (من نوع مختلف).
توجد بعض المناطق الحرجة داخل كود kernel حيث يجب تعطيل المقاطعات. ويجب أن تكون هذه المناطق الحرجة محدودة قدر الإمكان.
**************************************************************************
Interrupts and Exceptions
Exceptions are often discussed at the same time as interrupts. Unlike interrupts, exceptions occur synchronously with respect to the processor clock; 
they are often called synchronous interrupts. Exceptions are produced by the processor 
while executing instructions either in response to a programming error (e.g. divide by zero) or abnormal conditions that must be handled by 
the kernel (e.g. a page fault). Because many processor architectures handle exceptions in a similar manner to interrupts, the kernel infrastructure 
for handling the two is similar.

Simple definitions of the two:

Interrupts – asynchronous interrupts generated by hardware.

Exceptions – synchronous interrupts generated by the processor.

System calls (one type of exception) on the x86 architecture are implemented by the issuance of a software interrupt, which traps into the kernel and 
causes the execution of a special system call handler. Interrupts work in a similar way, except hardware (not software) issues interrupts.
**************************************************************************
Interrupts
Maskable – All Interrupt Requests (IRQs) issued by I/O devices give rise to maskable interrupts. A maskable interrupt can be in two states: 
masked or unmasked; a masked interrupt is ignored by the control unit as long as it remains masked.

Non-maskable – Only a few critical events (such as hardware failures) give rise to nonmaskable interrupts. Non-maskable interrupts are always recognized by the CPU.

Exceptions
Falts – Like Divide by zero, Page Fault, Segmentation Fault.

Traps – Reported immediately following the execution of the trapping instruction. Like Breakpoints.

Aborts – Aborts are used to report severe errors, such as hardware failures and invalid or inconsistent values in system tables.

For a device’s each interrupt, its device driver must register an interrupt handler.
**************************************************************************
Interrupt handler
An interrupt handler or interrupt service routine (ISR) is the function that the kernel runs in response to a specific interrupt:

Each device that generates interrupts has an associated interrupt handler.
The interrupt handler for a device is part of the device’s driver (the kernel code that manages the device).
In Linux, interrupt handlers are normal C functions, which match a specific prototype and thus enable the kernel to pass the handler information in a standard way. 
What differentiates interrupt handlers from other kernel functions is that the kernel invokes them in response to interrupts and that they run in a special context 
called interrupt context. This special context is occasionally called atomic context because code executing in this context is unable to block.

Because an interrupt can occur at any time, an interrupt handler can be executed at any time. It is imperative that the handler runs quickly, 
to resume the execution of the interrupted code as soon as possible. It is important that
**************************************************************************
To the hardware: the operating system services the interrupt without delay.
To the rest of the system: the interrupt handler executes in as short a period as possible.
At the very least, an interrupt handler’s job is to acknowledge the interrupt’s receipt to the hardware. However, interrupt handlers can often have a large amount of work to perform.

Process Context and Interrupt Context
The kernel accomplishes useful work using a combination of process contexts and interrupts context. Kernel code that services system calls issued 
by user applications runs on behalf of the corresponding application processes and is said to execute in the process context. Interrupt handlers, 
on the other hand, run asynchronously in the interrupt context. Process contexts are not tied to any interrupt context and vice versa.
**************************************************************************
Kernel code running in process context is preemptible. An interrupt context, however, always runs to completion and is not preemptible. 
Because of this, there are restrictions on what can be done from an interrupt context. Code executing from interrupt context cannot do the following:

Go to sleep or relinquish the processor
Acquire a mutex
Perform time-consuming tasks
Access user space virtual memory
Based on our idea, ISR or Interrupt Handler should be executed very quickly and it should not run for more time (it should not perform time-consuming tasks). 
What if, I want to do a huge amount of work upon receiving interrupts? So it is a problem, right? If we take more time to process, this will happen.
**************************************************************************
While the highest priority ISR is running, it doesn’t let other interrupts to run.
Interrupts with the same type will be missed.
To eliminate that problem, the processing of interrupts is split into two parts or halves:

Top halves
Bottom halves
Top halves and Bottom halves
**************************************************************************
Top half
The interrupt handler is the top half. 
The top half will run immediately upon receipt of the interrupt and performs only the work that is time-critical, 
such as acknowledging receipt of the interrupt or resetting the hardware.

Bottom half
The bottom half is used to process data, letting the top half to deal with new incoming interrupts. Interrupts are enabled 
when a bottom half runs. The interrupt can be disabled if necessary, but generally, this should be avoided as this goes against the basic purpose 
of having a bottom half – processing data while listening to new interrupts. The bottom half runs in the future, at a more convenient time, with all interrupts enabled.
**************************************************************************
For example, using the network card:

When network cards receive packets from the network, the network cards immediately issue an interrupt. This optimizes network throughput and latency and avoids timeouts.
The kernel responds by executing the network card’s registered interrupt.
The interrupt runs, acknowledges the hardware, copies the new networking packets into the main memory, and readies the network card for more packets. These jobs are important, time-critical, and hardware-specific work.
The kernel generally needs to quickly copy the networking packet into the main memory because the network data buffer on the networking card is fixed and minuscule in size, particularly compared to the main memory. Delays in copying the packets can result in a buffer overrun, with incoming packets overwhelming the networking card’s buffer and thus packets being dropped.
After the networking data is safely in the main memory, the interrupt’s job is done, and it can return control of the system to whatever code was interrupted when the interrupt was generated.
The rest of the processing and handling of the packets occurs later, in the bottom half.
If the interrupt handler function could process and acknowledge interrupts within a few microseconds consistently, then absolutely there is no need for top half/bottom half delegation.
**************************************************************************
There are 4 bottom half mechanisms are available in Linux:

Workqueue
Threaded IRQs
Softirq
Tasklets
You can see the Bottom Half tutorials Here. In our next tutorial, you can see the programming of Interrupts with ISR.
**************************************************************************