usb_driver structure
USB driver needs to do is register itself with the Linux USB subsystem (USB core). So while registering we need to give some information about which devices the driver supports and which functions to call when a device supported by the driver is inserted or removed from the system. All of this information is passed to the USB subsystem via usb_driver structure.

struct usb_driver {
  const char * name;
  int (* probe) (struct usb_interface *intf,const struct usb_device_id *id);
  void (* disconnect) (struct usb_interface *intf);
  int (* ioctl) (struct usb_interface *intf, unsigned int code,void *buf);
  int (* suspend) (struct usb_interface *intf, pm_message_t message);
  int (* resume) (struct usb_interface *intf);
  int (* reset_resume) (struct usb_interface *intf);
  int (* pre_reset) (struct usb_interface *intf);
  int (* post_reset) (struct usb_interface *intf);
  const struct usb_device_id * id_table;
  struct usb_dynids dynids;
  struct usbdrv_wrap drvwrap;
  unsigned int no_dynamic_id:1;
  unsigned int supports_autosuspend:1;
  unsigned int soft_unbind:1;
};
Where,

<name>: The driver name should be unique among USB drivers, and should normally be the same as the module name.

<probe>: The function needs to be called when a USB device is connected. 

<disconnect>: The function needs to be called when a USB device is disconnected.

<ioctl>: Used for drivers that want to talk to userspace through the “usbfs” filesystem.

<suspend>: Called when the device is going to be suspended by the system.

<resume>: Called when the device is being resumed by the system.

<reset_resume>: Called when the suspended device has been reset instead of being resumed.

<pre_reset>: Called by usb_reset_device when the device is about to be reset.

<post_reset>: Called by usb_reset_device after the device has been reset.

<id_table>: USB drivers use an ID table to support hotplugging. Export this with MODULE_DEVICE_TABLE(usb,…). This must be set or your driver’s probe function will never get called.

<dynids>: used internally to hold the list of dynamically added device ids for this driver.

<drvwrap>: Driver-model core structure wrapper.

<no_dynamic_id>: if set to 1, the USB core will not allow dynamic ids to be added to this driver by preventing the sysfs file from being created.

<supports_autosuspend>: if set to 0, the USB core will not allow auto suspend for interfaces bound to this driver.

<soft_unbind>: if set to 1, the USB core will not kill URBs and disable endpoints before calling the driver’s disconnect method.

USB interface drivers must provide a name, probe and disconnect methods, and an id_table. Other driver fields are optional.

id_table
The id_table is used in hotplugging. It holds a set of descriptors, and specialized data may be associated with each entry. That table is used by both user and kernel mode hotplugging support.

The following code tells the hotplug scripts that this module supports a single device with a specific vendor and product ID:

const struct usb_device_id etx_usb_table[] = {
    { USB_DEVICE( USB_VENDOR_ID, USB_PRODUCT_ID ) },    //Put your USB device's Vendor and Product ID
    { } /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, etx_usb_table);
Notes: Make sure that you have replaced the vendor id & device id with your USB device in the above code example.

probe
When a device is plugged into the USB bus that matches the device ID pattern that your driver registered with the USB core, the probe function is called.

The driver now needs to verify that this device is actually accepted or not. If it is accepted, it returns 0. If not, or if any error occurs during initialization, an error code (such as -ENOMEM or -ENODEV) is returned from the probe function.

Example snippet of the probe
/*
** This function will be called when USB device is inserted.
*/
static int etx_usb_probe(struct usb_interface *interface,
                        const struct usb_device_id *id)
{
    dev_info(&interface->dev, "USB Driver Probed: Vendor ID : 0x%02x,\t"
             "Product ID : 0x%02x\n", id->idVendor, id->idProduct);
    return 0;  //return 0 indicates we are managing this device
}
disconnect
When a device is plugged out or removed, this function will be getting called.

Example snippet of the disconnect
/*
** This function will be called when USB device is removed.
*/
static void etx_usb_disconnect(struct usb_interface *interface)
{
    dev_info(&interface->dev, "USB Driver Disconnected\n");
}
Example snippet of usb_driver structure
Once you have written the probe, disconnect functions, and id_table, then you have to assign their address to the usb_driver structure like below.

static struct usb_driver etx_usb_driver = {
    .name       = "EmbeTronicX USB Driver",
    .probe      = etx_usb_probe,
    .disconnect = etx_usb_disconnect,
    .id_table   = etx_usb_table,
};
As of now, we have finished the basic kinds of stuff. Now we need to register the USB device with a USB core.

Register the USB device driver to the USB Subsystem (USB core)
This API is used to register the USB driver to the USB subsystem.

usb_register (struct usb_driver * your_usb_driver);

Where,

<your_usb_driver>: The structure which will tell the address of probe, disconnect, and id_table.

Example
usb_register(&etx_usb_driver);
Deregister the USB device driver from the USB subsystem
This API is used to deregister the USB driver from the USB subsystem.

usb_deregister (struct usb_driver * your_usb_driver);

Where,

<your_usb_driver>: The structure which will tell the address of probe, disconnect, and id_table.

Example
usb_deregister(&etx_usb_driver);
Initialize and exit function
We have completed all the things. But where should we call the usb_register and usb_deregister function? It is just simple. Like a character device driver, we have to do this in __init and __exit functions. Refer to the below example.

static int __init etx_usb_init(void)
{
    return usb_register(&etx_usb_driver);
}
static void __exit etx_usb_exit(void)
{
    usb_deregister(&etx_usb_driver);
}
module_init(etx_usb_init);
module_exit(etx_usb_exit);
module_usb_driver
Is that all? Yes if you use the kernel older than 3.3. But if you are using the latest Linux kernel which is greater than 3.3, then there is another option that you can use. You can eliminate this usb_register, usb_deregister ,__init , __exit, module_init and module_exit functions in one line. ie, You can eliminate all the code which has been provided above can be replaced by below one line.

module_usb_driver(__usb_driver);
Where,

<__usb_driver>: usb_driver structure

This is the helper macro for registering a USB driver. This macro for USB drivers which do not do anything special in module init/exit. This eliminates a lot of boilerplate. Each module may only use this macro once, and calling it replaces module_init and module_exit.

Example Programming
We have written some very basic USB device drivers which will just print the Interface descriptor and Endpoint descriptor while inserting the device. And we have used both the old method ( module_init and module_exit) and the new method (module_usb_driver). You can choose anyone by changing the macro IS_NEW_METHOD_USED. If you set 0, then it will use the old method. If you set 1 or non-zero value, it will use the new method.

And one more point, we have used the dev_info API here to print the data. dev_info is similar to pr_info, but also print some information about device(struct device), passed to them as the first argument. This information may help to filter the system log for messages, belonging to the concrete device.

Just go through the code below. You can easily understand this if you have followed our previous character device driver tutorials.

Note: In this tutorial, I have not used any separate microcontrollers. I have used my ubuntu as a host which is installed by using VirtualBox and My mobile phone as a USB device. This is just for learning purposes. And I have used the Linux kernel 5.3.0-42-generic.
**********************************************************************************
