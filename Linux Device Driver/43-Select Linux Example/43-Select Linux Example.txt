Select Linux Example Device Driver
IO Multiplexing
The solution is to use a kernel mechanism for polling over a set of file descriptors. There are 3 options you can use in Linux:

poll
select
epoll
In this tutorial, we will focus on the select Linux example.

What is a select and its use?
The select API should have been deprecated years ago. But it is still there. Select provides the same functionality as the poll.

How to use a select in the Application?
Before we see the select API, we must be familiar with some other macros. We are going to watch the file descriptors for reading, writing, and error events. So we have to pass the file descriptors to the select API. The contents of a file descriptor set can be manipulated using the following macros:

FD_ZERO()
FD_SET()
FD_CLR()
FD_ISSET()
FD_ZERO()
This macro clears (removes all file descriptors from) the set. It should be employed as the first step in initializing a file descriptor set.

FD_SET()
This macro adds the file descriptor fd to the set. Adding a file descriptor that is already present in the set is a no-op, and does not produce an error.

FD_CLR()
This macro removes the file descriptor fd from the set. Removing a file descriptor that is not present in the set is a no-op, and does not produce an error.

FD_ISSET()
select modifies the contents of the sets according to the rules described below.

After calling select(), the FD_ISSET() macro can be used to test if a file descriptor is still present in a set. FD_ISSET() returns nonzero if the file descriptor fd is present in set, and zero if it is not.

Select()
Now we are good to go. Let’s see the select API below.

int select( int nfds, fd_set *readfds,  fd_set *writefds,  fd_set *exceptfds, struct timeval *timeout );
Where,

nfds – This argument should be set to the highest-numbered file descriptor in any of the three sets, plus 1. The indicated file descriptors in each set are checked, up to this limit.

For example, if you want to monitor the two file descriptors of 26 and 5. Then you have to provide 26 + 1 = 27, not 2. So, highest-numbered file descriptor + 1.

Note : select() can monitor only file descriptors numbers that are less than FD_SETSIZE which is 1024.
*******************************************************************************
readfds – The file descriptors in this set are watched to see if they are ready for reading. After select() has returned, readfds will be cleared of all file descriptors except for those that are ready for reading.

writefds – The file descriptors in this set are watched to see if they are ready for writing. After select() has returned, writefds will be cleared of all file descriptors except for those that are ready for writing.

exceptfds – The file descriptors in this set are watched for “exceptional conditions”. For example, POLLPRI in the poll. After select() has returned, exceptfds will be cleared of all file descriptors except for those for which an exceptional condition has occurred.

timeout – The timeout argument is a timeval structure that specifies the interval that select() should block waiting for a file descriptor to become ready. The call will block until either:

a file descriptor becomes ready;
the call is interrupted by a signal handler, or
the timeout expires.
If both fields of the timeval structure are zero, then select() returns immediately. (This is useful for polling.)

If timeout is specified as NULL, select() blocks indefinitely waiting for a file descriptor to become ready.

What is the difference between select and poll (select vs poll)?
select was introduced in BSD Unix, released in August 1983, whereas poll was introduced in SVR3 Unix, released in 1986.
Operations in poll and select is linear and slow because of having a lot of checks.
The main advantage of select is the fact that it is very portable – every UNIX-like OS has it. Some Unix systems do not support poll.
With select, the file descriptor sets are reconstructed on return, so each subsequent call must reinitialize them. The poll system call separates the input (events field) from the output (revents field), allowing the array to be reused without change.
The timeout parameter to select is undefined on return. So, we need to reinitialize it.
poll does not require the user to calculate the value of the highest-numbered file descriptor +1. Whereas in select, we have to calculate the nfds or pass the maximum number using FD_SETSIZE.
poll is more efficient for large-valued file descriptors. For example, when you want to wait for the events in the file descriptor (fd) 1000, poll will directly use that fd. But if you use this 1000 fd in select, it has to iterate (loop) from 0 to 999 to check any file has data.
In the select, we need to iterate over the file descriptors to check if it exists on the set returned from select. But in the poll, we can check only we wanted to.
In the poll, you can use the file descriptor which is more than 1024. But in select you cannot use it. If you use the file descriptor which is more than or equal to 1024 (FD_SETSIZE), then it may destroy your stack. How? select’s file descriptor sets are statically sized.
If you see the structure fd_set‘s declaration, it looks like the below.

/* fd_set for select and pselect.  */
typedef struct
{
  /* XPG4.2 requires this member name.  Otherwise avoid the name
     from the global namespace.  */
#ifdef __USE_XOPEN
  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
  __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
} fd_set;
Don’t get confused by seeing the above code. Actually, we can simplify the above structure like the below.

/* fd_set for select and pselect.  */
typedef struct
{
  long fds_bits[1024 / 64];  //__FD_SETSIZE = 1024, __NFDBITS = 8 * 8
} fd_set;
So, if you see the above-simplified structure, it allocates (8 * 16) bytes. Which are 1024 bits. So, you can maximum set or unset until 1024 bits. What will happen if you are trying to access more than that? it will corrupt other memory which is not intended to. So, it will destroy the stack.
*******************************************************************************
How to use a select in the Linux Device Driver?
We have already implemented the poll functionality in the Linux device driver side by our previous tutorial. So, we can use the same Linux device driver for select() too as select() also calls the same poll_wait() in the Linux kernel.

Select Linux Example Programming
I have not made any changes to that Linux device driver source code. And, the concept is also the same as the previous tutorial.

I’ve just copy-pasted the concept below from the previous tutorial for your understanding.

This example is just for educational purposes and explains an select in Linux device driver. This might not be the real use case.

In this example, I’ve created one sysfs entry (/sys/kernel/etx_sysfs/etx_value) with the reading and writing option. The select Linux example driver and application supposed to work like below.

Driver Concept
When you write data using the sysfs entry (/sys/kernel/etx_sysfs/etx_value), that means data is available in the kernel. So, we have to inform the userspace application to read the available data (Driver gives the permission to the app for reading).
When you read the data using the sysfs entry (/sys/kernel/etx_sysfs/etx_value), that means, data has been read by the kernel, and the userspace app has to write the data into the kernel space. So that driver can read the data. (Driver gives the permission to the app for writing).
So, whenever the app gets read permission, it can read the data from the driver and whenever the app gets the write permission, it can write some data into the driver.
Application concept
The application will open the driver’s device file (/dev/etx_device).
Clear the read and write fd using FD_ZERO().
Then set that descriptor to the read fd and write fd using FD_SET().
Set the timeout value in the struct timeval. In our example, we are setting 5 seconds timeout.
Then call the select function. So, every 5 seconds it will exit the select and again it calls the select.
If this app gets the read permission from the Linux kernel driver, then it reads the data.
If this app gets the write permission from the Linux kernel driver, then it writes the data to the driver.
*******************************************************************************************
